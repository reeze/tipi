# 第一节 生命周期和Zend引擎

## 一切的开始: SAPI接口
SAPI(Server Application Programming Interface)指的是PHP具体应用的编程接口，
就像PC一样，无论安装哪些操作系统，只要满足了PC的接口规范都可以在PC上正常运行，
PHP脚本要执行有很多种方式，通过Web服务器，或者直接在命令行下，也可以嵌入在其他程序中。

通常，我们使用Apache或者Nginx这类Web服务器来测试PHP脚本，或者在命令行下通过PHP解释器程序来执行。
脚本执行完后，Web服务器应答，浏览器显示应答信息，或者在命令行标准输出上显示内容。

我们很少关心PHP解释器在哪里。虽然通过Web服务器和命令行程序执行脚本看起来很不一样，
实际上它们的工作流程是一样的。命令行参数传递给PHP解释器要执行的脚本，
相当于通过url请求一个PHP页面。脚本执行完成后返回响应结果，只不过命令行的响应结果是显示在终端上。

脚本执行的开始都是以SAPI接口实现开始的。只是不同的SAPI接口实现会完成他们特定的工作，
例如Apache的mod_php SAPI实现需要初始化从Apache获取的一些信息，在输出内容是将内容返回给Apache，
其他的SAPI实现也类似。

下面几个小节将对一些常见的SAPI实现进行更为深入的介绍。

## 开始和结束
PHP开始执行以后会经过两个主要的阶段：处理请求之前的开始阶段和请求之后的结束阶段。
开始阶段有两个过程：第一个过程是模块初始化阶段（MINIT），
在整个SAPI生命周期内(例如Apache启动以后的整个生命周期内或者命令行程序整个执行过程中)，
该过程只进行一次。第二个过程是模块激活阶段（RINIT），该过程发生在请求阶段，
例如通过url请求某个页面，则在每次请求之前都会进行模块激活（RINIT请求开始）。
例如PHP注册了一些扩展模块，则在MINIT阶段会回调所有模块的MINIT函数。
模块在这个阶段可以进行一些初始化工作，例如注册常量，定义模块使用的类等等。
模块在实现时可以通过如下宏来实现这些回调函数：

	[c]
	PHP_MINIT_FUNCTION(myphpextension)
	{
		// 注册常量或者类等初始化操作
		return SUCCESS;
	}

请求到达之后PHP初始化执行脚本的基本环境，例如创建一个执行环境，包括保存PHP运行过程中变量名称和值内容的符号表，
以及当前所有的函数以及类等信息的符号表。然后PHP会调用所有模块的RINIT函数，
在这个阶段各个模块也可以执行一些相关的操作，模块的RINIT函数和MINIT回调函数类似：

	[c]
	PHP_RINIT_FUNCTION(myphpextension)
	{
		// 例如记录请求开始时间
		// 随后在请求结束的时候记录结束时间。这样我们就能够记录下处理请求所花费的时间了
		return SUCCESS;
	}

请求处理完后就进入了结束阶段，一般脚本执行到末尾或者通过调用exit()或die()函数，
PHP都将进入结束阶段。和开始阶段对应，结束阶段也分为两个环节，一个在请求结束后停用模块(RSHUWDOWN，对应RINIT)，
一个在SAPI生命周期结束（Web服务器退出或者命令行脚本执行完毕退出）时关闭模块(MSHUTDOWN，对应MINIT)。

	[c]
	PHP_RSHUTDOWN_FUNCTION(myphpextension)
	{
		// 例如记录请求结束时间，并把相应的信息写入到日至文件中。
		return SUCCESS;
	}


>**NOTE**
>想要了解扩展开发的相关内容，请参考第十三章 扩展开发

### 单进程SAPI生命周期
CLI/CGI模式的PHP属于单进程的SAPI模式。这类的请求在处理一次请求后就关闭。也就是只会经过如下几个环节：
开始 - 请求开始 - 请求关闭 - 结束 SAPI接口实现就完成了其生命周期。如图2.1所示：

![图2.1 单进程SAPI生命周期](../images/chapt02/02-01-01-cgi-lift-cycle.png)

### 多进程SAPI生命周期
通常PHP是编译为apache的一个模块来处理PHP请求。Apache一般会采用多进程模式，
Apache启动后会fork出多个子进程，每个进程的内存空间独立，每个子进程都会经过开始和结束环节，
不过每个进程的开始阶段只在进程fork出来以来后进行，在整个进程的生命周期内可能会处理多个请求。
只有在Apache关闭或者进程被结束之后才会进行关闭阶段，在这两个阶段之间会随着每个请求重复请求开始-请求关闭的环节。
如图2.2所示：

![图2.2 多进程SAPI生命周期](../images/chapt02/02-01-02-multiprocess-life-cycle.png)

### 多线程的SAPI生命周期
多线程模式和多进程中的某个进程类似，不同的是在整个进程的生命周期内会**并行**的重复着 请求开始-请求关闭的环节

![图2.3 多线程SAPI生命周期](../images/chapt02/02-01-013-multithreaded-lift-cycle.png)


## Zend引擎
Zend引擎是PHP实现的核心，提供了语言实现上的基础设施。例如：PHP的语法实现，脚本的编译运行环境，
扩展机制以及内存管理等，当然这里的PHP指的是官方的PHP实现(除了官方的实现，
目前比较知名的有facebook的hiphop实现，不过到目前为止，PHP还没有一个标准的语言规范)，
而PHP则提供了请求处理和其他Web服务器的接口(SAPI)。

目前PHP的实现和Zend引擎之间的关系非常紧密，甚至有些过于紧密了，例如很多PHP扩展都是使用的Zend API，
而Zend正是PHP语言本身的实现，PHP只是使用Zend这个内核来构建PHP语言的，而PHP扩展大都使用Zend API，
这就导致PHP的很多扩展和Zend引擎耦合在一起了，在笔者编写这本书的时候PHP核心开发者就提出将这种耦合解开，

目前PHP的受欢迎程度是毋庸置疑的，但凡流行的语言通常都会出现这个语言的其他实现版本，
这在Java社区里就非常明显，目前已经有非常多基于JVM的语言了，例如IBM的Project Zero就实现了一个基于JVM的PHP实现，
.NET也有类似的实现，通常他们这样做的原因无非是因为：他们喜欢这个语言，但又不想放弃原有的平台，
或者对现有的语言实现不满意，处于性能或者语言特性等（HipHop就是这样诞生的）。

很多脚本语言中都会有语言扩展机制，PHP中的扩展通常是通过Pear库或者原生扩展，在Ruby中则这两者的界限不是很明显，
他们甚至会提供两套实现，一个主要用于在无法编译的环境下使用，而在合适的环境则使用C实现的原生扩展，
这样在效率和可移植性上都可以保证。目前这些为PHP编写的扩展通常都无法在其他的PHP实现中实现重用，
HipHop的做法是对最为流行的扩展进行重写。如果PHP扩展能和ZendAPI解耦，则在其他语言中重用这些扩展也将更加容易了。

## 参考文献
Extending and Embedding PHP
