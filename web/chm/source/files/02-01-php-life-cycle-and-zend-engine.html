<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h2>第一节 生命周期和Zend引擎<a name='第一节 生命周期和Zend引擎'></a></h2>

<h3>一切的开始: SAPI接口<a name='一切的开始: SAPI接口'></a></h3>

<p>SAPI(Server Application Programming Interface)指的是PHP具体应用的编程接口，
就像PC一样，无论安装哪些操作系统，只要满足了PC的接口规范都可以在PC上正常运行，
PHP脚本要执行有很多种方式，通过Web服务器，或者直接在命令行下，也可以嵌入在其他程序中。</p>

<p>通常，我们使用Apache或者Nginx这类Web服务器来测试PHP脚本，或者在命令行下通过PHP解释器程序来执行。
脚本执行完后，Web服务器应答，浏览器显示应答信息，或者在命令行标准输出上显示内容。</p>

<p>我们很少关心PHP解释器在哪里。虽然通过Web服务器和命令行程序执行脚本看起来很不一样，
实际上它们的工作流程是一样的。命令行参数传递给PHP解释器要执行的脚本，
相当于通过url请求一个PHP页面。脚本执行完成后返回响应结果，只不过命令行的响应结果是显示在终端上。</p>

<p>脚本执行的开始都是以SAPI接口实现开始的。只是不同的SAPI接口实现会完成他们特定的工作，
例如Apache的mod_php SAPI实现需要初始化从Apache获取的一些信息，在输出内容是将内容返回给Apache，
其他的SAPI实现也类似。</p>

<p>下面几个小节将对一些常见的SAPI实现进行更为深入的介绍。</p>

<h3>开始和结束<a name='开始和结束'></a></h3>

<p>PHP开始执行以后会经过两个主要的阶段：处理请求之前的开始阶段和请求之后的结束阶段。
开始阶段有两个过程：第一个过程是模块初始化阶段（MINIT），
在整个SAPI生命周期内(例如Apache启动以后的整个生命周期内或者命令行程序整个执行过程中)，
该过程只进行一次。第二个过程是模块激活阶段（RINIT），该过程发生在请求阶段，
例如通过url请求某个页面，则在每次请求之前都会进行模块激活（RINIT请求开始）。
例如PHP注册了一些扩展模块，则在MINIT阶段会回调所有模块的MINIT函数。
模块在这个阶段可以进行一些初始化工作，例如注册常量，定义模块使用的类等等。
模块在实现时可以通过如下宏来实现这些回调函数：</p>

<pre class="c">PHP_MINIT_FUNCTION<span class="br0">&#40;</span>myphpextension<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// 注册常量或者类等初始化操作</span>
    <span class="kw1">return</span> SUCCESS<span class="sy0">;</span> 
<span class="br0">&#125;</span></pre>

<p>请求到达之后PHP初始化执行脚本的基本环境，例如创建一个执行环境，包括保存PHP运行过程中变量名称和值内容的符号表，
以及当前所有的函数以及类等信息的符号表。然后PHP会调用所有模块的RINIT函数，
在这个阶段各个模块也可以执行一些相关的操作，模块的RINIT函数和MINIT回调函数类似：</p>

<pre class="c">PHP_RINIT_FUNCTION<span class="br0">&#40;</span>myphpextension<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// 例如记录请求开始时间</span>
    <span class="co1">// 随后在请求结束的时候记录结束时间。这样我们就能够记录下处理请求所花费的时间了</span>
    <span class="kw1">return</span> SUCCESS<span class="sy0">;</span> 
<span class="br0">&#125;</span></pre>

<p>请求处理完后就进入了结束阶段，一般脚本执行到末尾或者通过调用exit()或die()函数，
PHP都将进入结束阶段。和开始阶段对应，结束阶段也分为两个环节，一个在请求结束后停用模块(RSHUWDOWN，对应RINIT)，
一个在SAPI生命周期结束（Web服务器退出或者命令行脚本执行完毕退出）时关闭模块(MSHUTDOWN，对应MINIT)。</p>

<pre class="c">PHP_RSHUTDOWN_FUNCTION<span class="br0">&#40;</span>myphpextension<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// 例如记录请求结束时间，并把相应的信息写入到日至文件中。</span>
    <span class="kw1">return</span> SUCCESS<span class="sy0">;</span> 
<span class="br0">&#125;</span></pre>

<blockquote class='note'>
<p>想要了解扩展开发的相关内容，请参考第十三章 扩展开发</p>
</blockquote>

<h4>单进程SAPI生命周期<a name='单进程SAPI生命周期'></a></h4>

<p>CLI/CGI模式的PHP属于单进程的SAPI模式。这类的请求在处理一次请求后就关闭。也就是只会经过如下几个环节： 
开始 - 请求开始 - 请求关闭 - 结束 SAPI接口实现就完成了其生命周期。如图2.1所示：</p>

<p><div class='book-img'><img src="02-01-01-cgi-lift-cycle.png" alt="图2.1 单进程SAPI生命周期" /><div class='book-img-desc'>图2.1 单进程SAPI生命周期</div></div></p>

<h4>多进程SAPI生命周期<a name='多进程SAPI生命周期'></a></h4>

<p>通常PHP是编译为apache的一个模块来处理PHP请求。Apache一般会采用多进程模式，
Apache启动后会fork出多个子进程，每个进程的内存空间独立，每个子进程都会经过开始和结束环节，
不过每个进程的开始阶段只在进程fork出来以来后进行，在整个进程的生命周期内可能会处理多个请求。
只有在Apache关闭或者进程被结束之后才会进行关闭阶段，在这两个阶段之间会随着每个请求重复请求开始-请求关闭的环节。
如图2.2所示：</p>

<p><div class='book-img'><img src="02-01-02-multiprocess-life-cycle.png" alt="图2.2 多进程SAPI生命周期" /><div class='book-img-desc'>图2.2 多进程SAPI生命周期</div></div></p>

<h4>多线程的SAPI生命周期<a name='多线程的SAPI生命周期'></a></h4>

<p>多线程模式和多进程中的某个进程类似，不同的是在整个进程的生命周期内会<strong>并行</strong>的重复着 请求开始-请求关闭的环节</p>

<p><div class='book-img'><img src="02-01-013-multithreaded-lift-cycle.png" alt="图2.3 多线程SAPI生命周期" /><div class='book-img-desc'>图2.3 多线程SAPI生命周期</div></div></p>

<h3>Zend引擎<a name='Zend引擎'></a></h3>

<p>Zend引擎是PHP实现的核心，提供了语言实现上的基础设施。例如：PHP的语法实现，脚本的编译运行环境，
扩展机制以及内存管理等，当然这里的PHP指的是官方的PHP实现(除了官方的实现，
目前比较知名的有facebook的hiphop实现，不过到目前为止，PHP还没有一个标准的语言规范)，
而PHP则提供了请求处理和其他Web服务器的接口(SAPI)。</p>

<p>目前PHP的实现和Zend引擎之间的关系非常紧密，甚至有些过于紧密了，例如很多PHP扩展都是使用的Zend API，
而Zend正是PHP语言本身的实现，PHP只是使用Zend这个内核来构建PHP语言的，而PHP扩展大都使用Zend API，
这就导致PHP的很多扩展和Zend引擎耦合在一起了，在笔者编写这本书的时候PHP核心开发者就提出将这种耦合解开，</p>

<p>目前PHP的受欢迎程度是毋庸置疑的，但凡流行的语言通常都会出现这个语言的其他实现版本，
这在Java社区里就非常明显，目前已经有非常多基于JVM的语言了，例如IBM的Project Zero就实现了一个基于JVM的PHP实现，
.NET也有类似的实现，通常他们这样做的原因无非是因为：他们喜欢这个语言，但又不想放弃原有的平台，
或者对现有的语言实现不满意，处于性能或者语言特性等（HipHop就是这样诞生的）。</p>

<p>很多脚本语言中都会有语言扩展制止，PHP中的扩展通常是通过Pear库或者原生扩展，在Ruby中则这两者的界限不是和明显，
他们甚至会提供两套实现，一个主要用于在无法编译的环境下使用，而在合适的环境则使用C实现的原生扩展，
这样在效率和可移植性上都可以保证。目前这些为PHP编写的扩展通常都无法在其他的PHP实现中实现重用，
HipHop的做法是对最为流行的扩展进行重写。如果PHP扩展能和ZendAPI解耦，则在其他语言中重用这些扩展也将更加容易了。</p>

<h3>参考文献<a name='参考文献'></a></h3>

<p>Extending and Embedding PHP</p>
		</div>
	</body>
</html>
